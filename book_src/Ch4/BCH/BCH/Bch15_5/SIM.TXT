
Help text file for bch.exe program that generate binary (n,k) BCH code.

bch.exe program uses following input files:
bch.in - to specify input parameters of bch code, only this file 
	should be changed
bch.dat - data needed to generate enc.vhd and sym.vhd files
bch1.dat - data needed to generate dec.vhd if t (no. of erroers) = 1
bch2.dat - data needed to generate dec.vhd if t = 2
bch3.dat - data needed to generate dec.vhd if t > 2
bchs.dat - data needed to generate sym.cmd and sym.cme

bch.exe generate (overwrite !!!) following files:
const.vhd - vhdl package file that contains useful constant
enc.vhd - vhdl file generating bch code encoder
dec.vhd - vhdl file generating bch code decoder
sim.vhd - vhdl file generating file for simulation encoder and decoder
sim.cmd - command file for simulation before synthesis
sim.cme - command file for simulation after synthesis

bch.in file should consists of following:
m= xx - specify width of Galois Field GF(2^m), n=2^m-1
t= xx - specify number of erroers to be may corrected

program option (placed in bch.in):
-oxx - for t>2 circuit option;
	xx = 2 - parallel archtecture
	xx = 3 - serial archtecture - prefered.
-sxx - generate sym.cmd and sym.cme with specified 
	by xx simulation cicle; simulation time ~ xx*n*interleave
	xx=0 - do not generate simulation command files.
-ixx - xx - interleave number. The frequency of Berklacamp-Massey 
	Algorithm and data transfer (syndrome calculation) freqency.
	f_BMA = interleave * f_syn
+(-)m - with '+' or without '-' design optimisation. 



There are following BCH codes for m= 4 and t<=3. (n,k,t)
(15, 11, 1) 	(15, 7, 2) 	(15, 5, 3) 	



	---------------- ENCODER----------------

ering - LFSR Linear Feedback Shift Registers
		Reg= 10		XOR= 5
ecount - counter (control system)
		Reg= 5		XOR= 1
ENCODER --
		Reg= 1		XOR= 0
	total	Reg= 16		XOR= 6




	-------------- DECODER ---------------

--------------- Syndromes calculation ------------
dsyn1 - syndromes  1 2 4
		Reg= 4		XOR= 6
dsyn3 - syndromes  3
		Reg= 4		XOR= 4
dsyn5 - syndromes  5
		Reg= 2		XOR= 2
	total	Reg= 10		XOR= 12

--------------- Chien Search ------------
dcheq - check if Chien search equal zero - found an error
		Reg= 0		XOR= 8
dch1 - Chien Search for x^1
		Reg= 4		XOR= 1
dch2 - Chien Search for x^2
		Reg= 4		XOR= 2
dch3 - Chien Search for x^3
		Reg= 4		XOR= 3
	total	Reg= 12		XOR= 14

--------------- Syndormes rearranging ------------
dmul21 - 2 to 1 multiplexers
		Reg= 0 * 4 = 0	XOR= 0 * 4 = 0
drdce - m registers with clock enable
		Reg= 4 * 5 = 20	XOR= 0 * 5 = 0
	total	Reg= 20		XOR= 0

--------------- Berlekamp-Massey Algorithm ----
dmul21 - 2 to 1 multiplexers
dmli - multiply by L^i
		Reg= 0		XOR= 1
dinv - inversion/division
		Reg= 8		XOR= 17
dsdbmRing - bit-Serial Dual Basis Multiplier Ring
		Reg= 8		XOR= 17
drdce - m registers with clock enable
		Reg= 4		XOR= 0
drdceSOne - m registers with set to one
		Reg= 4 * 2 = 8	XOR= 0 * 2 = 0
drd1ce - single register with clock enable
		Reg= 1 * 2 = 2	XOR= 0 * 2 = 0
dsdbm - bit-serial dual basis multiplier
		Reg= 0		XOR= 3
dshpe - m shift registers (ring) with parallel enable
		Reg= 4		XOR= 0
dshr - m shift registers (ring) with reset and addition
		Reg= 4 * 2 = 8	XOR= 1 * 2 = 2
dandm - m AND gates
		Reg= 0 * 4 = 0	XOR= 0 * 4 = 0
dxort - t XOR gates
		Reg= 0 * 4 = 0	XOR= 3 * 4 = 12
dssbm - bit-serial standard basis multiplier
		Reg= 4		XOR= 5
	total	Reg= 42		XOR= 57

--------------- The buffor  ----
dbuf - buffor for storing data to be corrected
		Reg= 11		XOR= 1
	total	Reg= 11		XOR= 1

--------------- The control system  ----
dci - interleave counter
		Reg= 1		XOR= 0
dca - less signficant control counter
		Reg= 3		XOR= 2
dcb - more signficant control counter
		Reg= 3		XOR= 2
dcl - degree of error polynomial
		Reg= 3		XOR= 3
drd1ce - single register
		Reg= 1 * 5 = 5	XOR= 0 * 5 = 0
dcount - control system
	total	Reg= 15		XOR= 7


	DECODER total
		Reg= 110		XOR= 91



GF(2^4) generated by polynomial: 1 + x^1 + x^4
  no.  Standard    Dual basis
   -   0000     0000
   0   1000     1000
   1   0100     0001
   2   0010     0010
   3   0001     0100
   4   1100     1001
   5   0110     0011
   6   0011     0110
   7   1101     1101
   8   1010     1010
   9   0101     0101
  10   1110     1011
  11   0111     0111
  12   1111     1111
  13   1011     1110
  14   1001     1100
  15   1000     1000